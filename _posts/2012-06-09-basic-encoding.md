---
layout:     post
title:      理解encoding
comments:   true
category:   basic
tags:       [basic, encoding]
published:  true
---

> 计算机只能识别0和1

人类利用了半导体的电磁特性(正负两极), 创造了CPU/内存/硬盘等具有记忆功能的设备.
无论这些设备多么复杂, 其存储的数据只有两种, 即0与1.  人类用10个手指来计数, 而计算机只有2个手指.
与英文单词类似(由一连串的字母组成), 可以把一连串的0和1组合起来, 表达任何信息.
无论是一张图片, 还是一个文档, 其本质上都是一连串的0和1.
也许你会问: 如何解读这些0和1呢? 我们来制定了一个对应关系表:

    h -> 01101000
    j -> 01101010
    k -> 01101011
    l -> 01101100

如果有这样一个0/1串: `01101000011010100110101101101100`  
为了表达方便, 把一个0/1位, 称为一个bit(比特); 把连续的8个bit, 称为一个byte(字节).  
上述0/1串可以写成这样:

    ---------------------------------------------
    | 01101000 | 01101010 | 01101011 | 01101100 |
    ---------------------------------------------

根据对照表, 可以解读出: `hjkl`

再来解读另一个0/1串:

    ---------------------------------------------
    | 01101000 | 00110100 | 00101100 | 01101011 |
    ---------------------------------------------

根据对照表, 无法解读中间两个byte: `h??k` (使用`?`表示解码失败的byte)  
解码失败的根本原因是, 对照表不齐全, 因此不能对任意的byte解码.

幸好, 有另一个比较全的对照表, 称之为ASCII码对照表.  
用ASCII对之解码后, 得到: `h4,k`. 值得我们注意的是, ASCII把`00110100`翻译成了`4`.  
字形`4`和数字`4`有本质的区别, 前者是用来表达的(视觉或听觉), 后者用来计数的抽象值(看不见摸不着).  
比如, `13800138000`可以是一套房的金额, 也可以是一个电话号码, 在不同的语境中, 数字所表示的含义不同.  

实际上, 所有的信息都可以用数字来表示, 另外需要一个对照表, 来解释这些数字.  
二进制数`100`, 与十进制数`4`, 本质上是一样的, 两者都是抽象值, 表达方式不同而已.

然而, ASCII码也不是齐全的. 比如: `11100100`是无法用ASCII来解读的.  
由于一个byte(8bit)最多只能表达`2^8=256`种不同意思, 我们需要多个byte才能表达所有的中文字符.

中文编码方式多种多样, 同样一个字, 使用不同的对照表, 写成byte串后, 有可能不同. 我以`中`字为例.

    UTF8:   11100100 10111000 10101101
    UTF16:  00101101 01001110
    UTF32:  00101101 01001110 00000000 00000000
    GB2312: 11010110 11010000
    GBK:    11010110 11010000
    GB18030:11010110 11010000

其中, GB2312/GBK/GB18030都属于中文特有的编码, 是我国科学家制定的.  
由于向后兼容, 所以三者把`中`字编码成相同的byte串.  

unicode定义了全世界所有的文字/符号的标号, 从0开始, 依次排列下去.

    -------+-------+----------------------------
      id   |  glyph|  name
    -------|-------|----------------------------
       ... |  ...  | ...
       106 |  j    | LATIN SMALL LETTER J
       107 |  k    | LATIN SMALL LETTER K
       108 |  l    | LATIN SMALL LETTER L
       ... |  ...  | ...
     20013 |  中   | CJK character Nelson   81
       ... |  ...  | ...
    -------+-------+----------------------------

可以看到, `中`排在第20013位. 为了把`中`字保存到文件中, 必须把抽象的数字20013, 编码成byte串.  
虽然UTF8/UTF16/UTF32把`中`字编码为不同的byte串, 但是它们都表达同样的意思, 即数字20013.  
把从`中`编码成UTF-N, 经历了两次对照表lookup, 即, 先unicode对照表, 再UTF-N对照表.  

打开一个含有`中`字的文件前, 必须要知道文件的编码方式, 否则就会导致乱码.  
例如, 用UTF16编码`中`字后, 保存到文件中, 读取文件时, 却用LATIN1进行解码, 就得到了`-N`.

> `乱码`并不一定要表现为: `ߩi>G�_��`. 一切错误的解码都称为`乱码`, 尽管看起来不像!

我认为, 理解字符编码很重要.

说明:   
-----

- 本文使用到了`echo`, `iconv`, `bc`, `uniname`等linux程序.  
- 在vim中转化编码, 请参考: <http://hjkl.me/vim/2012/06/04/vim-encoding.html>
